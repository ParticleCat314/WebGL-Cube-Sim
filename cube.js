

//const colors_v2 = [0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,1,0.4,0,1,1,0.4,0,1,1,0.4,0,1,1,0.4,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,1,1,0,0,1,1,0,0,1,1,0,0,1,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,1,1,0,1,1,1,0,1,1,1,0,1,1,1,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,1,0.4,0,1,1,0.4,0,1,1,0.4,0,1,1,0.4,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,1,1,0,0,1,1,0,0,1,1,0,0,1,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,1,0.4,0,1,1,0.4,0,1,1,0.4,0,1,1,0.4,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,1,1,0,0,1,1,0,0,1,1,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,1,0.4,0,1,1,0.4,0,1,1,0.4,0,1,1,0.4,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,1,1,0,1,1,1,0,1,1,1,0,1,1,1,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,1,0.4,0,1,1,0.4,0,1,1,0.4,0,1,1,0.4,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,1,0.4,0,1,1,0.4,0,1,1,0.4,0,1,1,0.4,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,1,0.4,0,1,1,0.4,0,1,1,0.4,0,1,1,0.4,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,1,1,0,1,1,1,0,1,1,1,0,1,1,1,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,1,0.4,0,1,1,0.4,0,1,1,0.4,0,1,1,0.4,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,1,0.4,0,1,1,0.4,0,1,1,0.4,0,1,1,0.4,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,1,1,0,0,1,1,0,0,1,1,0,0,1,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,1,1,0,1,1,1,0,1,1,1,0,1,1,1,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,1,1,0,0,1,1,0,0,1,1,0,0,1,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,1,1,0,0,1,1,0,0,1,1,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,1,1,0,1,1,1,0,1,1,1,0,1,1,1,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,1,1,0,1,1,1,0,1,1,1,0,1,1,1,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,1,0,0,1,1,0,0,1,1,0,0,1,1,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,1,1,0,0,1,1,0,0,1,1,0,0,1,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,1,1,0,1,1,1,0,1,1,1,0,1,1,1,0,1,1,0,0,1,1,0,0,1,1,0,0,1,1,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,1,1,0,0,1,1,0,0,1,1,0,0,1,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,1,0,0,1,1,0,0,1,1,0,0,1,1,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,1,1,0,0,1,1,0,0,1,1,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,1,0,0,1,1,0,0,1,1,0,0,1,1,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,1,1,0,1,1,1,0,1,1,1,0,1,1,1,0,1,1,0,0,1,1,0,0,1,1,0,0,1,1,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,1,0,0,1,1,0,0,1,1,0,0,1,1,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,1,0,0,1,1,0,0,1,1,0,0,1,1,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,1,1,0,1,1,1,0,1,1,1,0,1,1,1,0,1,1,0,0,1,1,0,0,1,1,0,0,1,1,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,1,0,0,1,1,0,0,1,1,0,0,1,1,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1]
/// OLD COLOR STUFF
//const colorBuffer = gl.createBuffer();
//gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
//gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(colors_v2), gl.STATIC_DRAW);
//const color = gl.getAttribLocation(shader1.program, "vertex_color");
//gl.vertexAttribPointer(color,4,gl.FLOAT,false,0,4*colors_v2.length/12);
//gl.enableVertexAttribArray(color)
//gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
//var offset = cube*6*4*colors_v2.length/162; /// This is a kinda dodgy way of getting the colors...
//gl.vertexAttribPointer(color,4,gl.FLOAT,false,0,offset);



const canvas = document.getElementById("glCanvas");
const gl = canvas.getContext("webgl2",antialias=true);
let width = window.innerHeight*0.6;
let height = window.innerHeight*0.6;
canvas.width = window.innerHeight*0.6;
canvas.height = window.innerHeight*0.6;

let M=3;
let N=3;
let O=3;
const S = 2.1;
var k = 1.05*(M-3);
var j = S*(M-3);
let R = [S-k+j,0,[-1,0,0]];
let r = [S-k+j,0,[1,0,0]];
let L = [-S-k,0,[-1,0,0]];
let l = [-S-k,0,[1,0,0]];
let U = [S-k+j,1,[0,-1,0]];
let u = [S-k+j,1,[0,1,0]];
let D = [-S-k,1,[0,-1,0]];
let d = [-S-k,1,[0,1,0]];
let B = [-S-k,2,[0,0,-1]];
let b = [-S-k,2,[0,0,1]];
let F = [S-k+j,2,[0,0,-1]];
let f = [S-k+j,2,[0,0,1]];


var cam = new OrbitCam([-5-M*0.03,0,0],fov=35,width/height);
let anim = false;


class sub_cube{
    constructor(pos,color){
        /// [Math.floor(n/9),Math.floor(n%9)/3,0] --- whaaaaaaaaaaaat does this do???
        ///this.types = types;
        this.eFaces = color;
        var sep = -S;
        var l = S;
        this.pos = [pos[0]*l+sep-k,pos[1]*l+sep-k,pos[2]*l+sep-k];
        this.model = mat4.create();//new Float32Array(16);
        this.model = gmat4.translate(this.model,this.pos);
        this.model = (this.model);
        //this.tpos = this.pos;        
        this.rotation = mat3.create();
    }


    get_pos(){
        let position = [this.model[3],this.model[7],this.model[11]];
        return position;
    }
}

function genCube(x,y,z,S){
    var cubes = []
    for (var n = 0; n<x*y*z; n++){
        let pos = [n%x,Math.floor(n/x)%y,Math.floor((n)/(x*y))];
        //let temp = [1*(1-pos[0]),(-(M+1)+pos[0]),(1-pos[1]),(-1+pos[1]),1*(1-pos[2]),(-1+pos[2])];
        let temp = [((1)-pos[0]),(-(x-2)+pos[0]),((1)-pos[1]),(-(y-2)+pos[1]),((1)-pos[2]),(-(z-2)+pos[2])];
        cubes.push(new sub_cube(pos,temp,S));
    }

    return cubes;
}

var cube1_corners = genCube(M,N,O);


function resizeCube(){
    listmove = false;
    anim = false;
    M = document.getElementById("Xsize").value;
    N = document.getElementById("Ysize").value;
    O = document.getElementById("Zsize").value;
    console.log(M)
    cube1_corners = [];
    cube1_corners = genCube(M,N,O,S);
}

function main() {
    if (gl == null){alert("Unable to initialize WebGL :("); return;}

    var vertex_buffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, vertex_buffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(cube_positions), gl.STATIC_DRAW);
    gl.bindBuffer(gl.ARRAY_BUFFER, null);

    var Index_Buffer = gl.createBuffer();
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, Index_Buffer);
    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(cube_indices), gl.STATIC_DRAW);
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);

    const shader1 = new Shader(gl,fragCode,vertCode);
    shader1.bind(vertex_buffer,Index_Buffer);

    const coord = gl.getAttribLocation(shader1.program, "coordinates");
    gl.vertexAttribPointer(coord, 3, gl.FLOAT, false, 0, 0);
    gl.enableVertexAttribArray(coord);



    const normalBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, normalBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertexNormals),gl.STATIC_DRAW);
    var normals = gl.getAttribLocation(shader1.program,"normals");
    gl.vertexAttribPointer(normals,3,gl.FLOAT,false,0,0);
    gl.enableVertexAttribArray(normals);




    gl.enable(gl.DEPTH_TEST);
    gl.depthFunc(gl.LEQUAL);
    gl.clearColor(0.1,0.1,0.1,1.0);
    gl.clearDepth(1.0);
    gl.viewport(0,0,width,height);


    var drag = false;
    var startxy = [0,0];
    var distxy = [0,0];
    var totalx = 0;
    var totaly = 0;
    var total = 0;
    var keydown = false;

    let view_loc = gl.getUniformLocation(shader1.program,"view");
    let proj_loc = gl.getUniformLocation(shader1.program,"projection");


    const model_loc = gl.getUniformLocation(shader1.program,"model");
    const normal_loc = gl.getUniformLocation(shader1.program,"normalMatrix");
    const model_rot_loc = gl.getUniformLocation(shader1.program,"modelRotation");
    const time_loc = gl.getUniformLocation(shader1.program,"time");
    const Face = gl.getUniformLocation(shader1.program,"faces");


    let model_rot = gmat4.scale(gmat4.rotate(mat4.create(),0.7,[0,0,1]),[0.5,0.5,0.5]);
    let old = model_rot;
    gl.uniformMatrix4fv(view_loc,gl.FALSE,transpose(cam.lookAt));
    gl.uniformMatrix4fv(proj_loc,gl.FALSE,transpose(cam.projection));
    gl.uniformMatrix4fv(model_rot_loc,gl.FALSE,transpose(model_rot));
    

    let dets = null;
    let listmove = true;
    let moves = [f,u,F,U,F,L,f,f,U,F,U,f,u,F,l];
    let move = moves[0];
    let nn = 0;
    let time = 0.0;

    

    function render_scene(delta){
        time += delta;
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFER_BIT);
        if (anim==true && listmove==false){
            interpolate_anim(0,PI/2,dets,25);
        }
        else if (moves.length != 0 && anim==false && listmove==true){
            anim = true;
            move = moves[nn];
            nn = (nn+1)%(moves.length);
        }
        else if (anim==true) {
            interpolate_anim(0,PI/2,move,15);
        }
        manage_input();
        if (drag){model_rot = cam.rotate(distxy,delta,model_rot,old,drag);
            gl.uniformMatrix4fv(model_rot_loc,gl.FALSE,transpose(model_rot));
        }
        
        //if (drag){
        //    totalx += 0.3*delta*distxy[1];
        //    totaly += 0.3*delta*distxy[0];
        //    model_rot = gmat4.rotate(old,-totalx*3.14/360,[0,0,1]);
        //    let temp = gmat4.rotate(model_rot,-totaly*3.14/360,[0,1,0]);
        //    model_rot = temp;
        //    gl.uniformMatrix4fv(model_rot_loc,gl.FALSE,transpose(model_rot));
        //}
        //gl.uniform1f(time_loc,time);

        for (cube in cube1_corners){
            gl.uniformMatrix4fv(model_loc,gl.FALSE,transpose(cube1_corners[cube].model));
            gl.uniform1fv(Face,cube1_corners[cube].eFaces);
            let normalMatrix = mat4.create();//new Float32Array(16);
            normalMatrix = mat4.invert(cam.lookAt);
            //glMatrix.mat4.identity(normalMatrix);//mat4.create();
            //glMatrix.mat4.invert(normalMatrix, transpose(cam.lookAt));
            //glMatrix.mat4.transpose(normalMatrix, normalMatrix);
            gl.uniformMatrix4fv(normal_loc,gl.FALSE,normalMatrix);
            gl.drawElements(gl.TRIANGLES, cube_indices.length, gl.UNSIGNED_SHORT,0);       
        }
    }
    function rotate_face(value,index,rot,angle=3.14159265/4){
        let axis = rot;
        let rottt = mat3.rotateN2(-angle,axis);
        let rottt2 = mat3.rotateN2(-angle,axis);
        for (cube in cube1_corners){
            if (~~(cube1_corners[cube].pos[index])==~~(value)){
                cube1_corners[cube].rotation = mat3.dot(rottt,cube1_corners[cube].rotation);
                cube1_corners[cube].pos = mat3.mul(rottt2,cube1_corners[cube].pos);
                cube1_corners[cube].model = gmat4.fromPosRot(cube1_corners[cube].pos,cube1_corners[cube].rotation);
            }
        }
    }

    function manage_input(){

        document.addEventListener('keydown', (event)=>{
            if (anim == false){
                if (event.key == 'r' && keydown == false){
                    dets = r;
                    anim = true;
                    console.log("stretch");
                    keydown = true;
                }

                else if (event.key == 'l' && keydown == false){
                    //rotate_face(-S,0,[1,0,0]);
                    dets = l;
                    anim = true;
                    console.log("stretch");
                    keydown = true;
                }

                else if (event.key == 'u' && keydown == false){
                    //rotate_face(S,1,[0,1,0]);
                    dets = u;
                    anim = true;
                    console.log("stretch");
                    keydown = true;
                }

                else if (event.key == 'd' && keydown == false){
                    //rotate_face(-S,1,[0,1,0]);
                    dets = d;
                    anim = true;
                    console.log("stretch");
                    keydown = true;
                }

                else if (event.key == 'f' && keydown == false){
                    //rotate_face(S,2,[0,0,1]);
                    dets = f;
                    anim = true;
                    console.log("stretch");
                    keydown = true;
                }

                else if (event.key == 'b' && keydown == false){
                    //rotate_face(-S,2,[0,0,1]);
                    dets = b;
                    anim = true;
                    console.log("stretch");
                    keydown = true;
                }

                else if (event.key == 'R' && keydown == false){
                    dets = R;
                    anim = true;
                    console.log("stretch");
                    keydown = true;
                }

                else if (event.key == 'L' && keydown == false){
                    //rotate_face(-S,0,[1,0,0]);
                    dets = L;
                    anim = true;
                    console.log("stretch");
                    keydown = true;
                }

                else if (event.key == 'U' && keydown == false){
                    //rotate_face(S,1,[0,1,0]);
                    dets = U;
                    anim = true;
                    console.log("stretch");
                    keydown = true;
                }

                else if (event.key == 'D' && keydown == false){
                    //rotate_face(-S,1,[0,1,0]);
                    dets = D;
                    anim = true;
                    console.log("stretch");
                    keydown = true;
                }

                else if (event.key == 'F' && keydown == false){
                    //rotate_face(S,2,[0,0,1]);
                    dets = F;
                    anim = true;
                    console.log("stretch");
                    keydown = true;
                }

                else if (event.key == 'B' && keydown == false){
                    //rotate_face(-S,2,[0,0,1]);
                    dets = B;
                    anim = true;
                    console.log("stretch");
                    keydown = true;
                }
            }


            
            

        },false);

        document.addEventListener('shift', (event)=>{keydown = false;},false);
        document.addEventListener('keyup', (event)=>{keydown = false;},false);
        document.addEventListener('mousedown',(event)=>{drag=true; startxy = [event.clientX,event.clientY]},false);
        document.addEventListener('mouseup',(event)=>{drag=false;},false);
        document.addEventListener('mousemove',(event)=>{if (drag){distxy = [(event.clientX-startxy[0]),(event.clientY-startxy[1])];}},false);        
    }


    function interpolate_anim(start,end,rot_details,steps=1){
        var step = (end-start)/steps;
        total += step;
        //console.log(total);
        rotate_face(rot_details[0],rot_details[1],rot_details[2],angle=step);
        if ((end)<total) {anim = false; rotate_face(rot_details[0],rot_details[1],rot_details[2],angle=end-total); total=0;}
    }

    var then = 0;
    function render(now){
        now *= 0.001;
        const deltaTime = now-then;
        then = now;
        render_scene(deltaTime);
        requestAnimationFrame(render);
    }
    requestAnimationFrame(render);
    function resizeEvent(){
        let canvas = document.getElementById("glCanvas");
        canvas.width = window.innerHeight*0.6;
        canvas.height = window.innerHeight*0.6;//window.innerHeight*0.4;
        //console.log(window.innerHeight);
        gl.viewport(0,0,canvas.width,canvas.height);
        let aspectRatio = canvas.height/canvas.width;
        cam.projection = cam.viewportChanged(aspectRatio);
        gl.uniformMatrix4fv(proj_loc,gl.FALSE,transpose(cam.projection));

    }
    window.onresize = resizeEvent;
}

window.onload = main;

