

var colors_v2 = [0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,1,0.4,0,1,1,0.4,0,1,1,0.4,0,1,1,0.4,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,1,1,0,0,1,1,0,0,1,1,0,0,1,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,1,1,0,1,1,1,0,1,1,1,0,1,1,1,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,1,0.4,0,1,1,0.4,0,1,1,0.4,0,1,1,0.4,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,1,1,0,0,1,1,0,0,1,1,0,0,1,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,1,0.4,0,1,1,0.4,0,1,1,0.4,0,1,1,0.4,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,1,1,0,0,1,1,0,0,1,1,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,1,0.4,0,1,1,0.4,0,1,1,0.4,0,1,1,0.4,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,1,1,0,1,1,1,0,1,1,1,0,1,1,1,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,1,0.4,0,1,1,0.4,0,1,1,0.4,0,1,1,0.4,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,1,0.4,0,1,1,0.4,0,1,1,0.4,0,1,1,0.4,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,1,0.4,0,1,1,0.4,0,1,1,0.4,0,1,1,0.4,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,1,1,0,1,1,1,0,1,1,1,0,1,1,1,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,1,0.4,0,1,1,0.4,0,1,1,0.4,0,1,1,0.4,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,1,0.4,0,1,1,0.4,0,1,1,0.4,0,1,1,0.4,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,1,1,0,0,1,1,0,0,1,1,0,0,1,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,1,1,0,1,1,1,0,1,1,1,0,1,1,1,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,1,1,0,0,1,1,0,0,1,1,0,0,1,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,1,1,0,0,1,1,0,0,1,1,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,1,1,0,1,1,1,0,1,1,1,0,1,1,1,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,1,1,0,1,1,1,0,1,1,1,0,1,1,1,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,1,0,0,1,1,0,0,1,1,0,0,1,1,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,1,1,0,0,1,1,0,0,1,1,0,0,1,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,1,1,0,1,1,1,0,1,1,1,0,1,1,1,0,1,1,0,0,1,1,0,0,1,1,0,0,1,1,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,1,1,0,0,1,1,0,0,1,1,0,0,1,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,1,0,0,1,1,0,0,1,1,0,0,1,1,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,1,1,0,0,1,1,0,0,1,1,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,1,0,0,1,1,0,0,1,1,0,0,1,1,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,1,1,0,1,1,1,0,1,1,1,0,1,1,1,0,1,1,0,0,1,1,0,0,1,1,0,0,1,1,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,1,0,0,1,1,0,0,1,1,0,0,1,1,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,1,0,0,1,1,0,0,1,1,0,0,1,1,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,1,1,0,1,1,1,0,1,1,1,0,1,1,1,0,1,1,0,0,1,1,0,0,1,1,0,0,1,1,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,1,0,0,1,1,0,0,1,1,0,0,1,1,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1]

const canvas = document.getElementById("glCanvas");
const gl = canvas.getContext("webgl");

class sub_cube{
    constructor(pos,types){
        this.types = types;
        this.colors = [];
    
        var sep = -1.1;
        var l = 1.1;
        this.pos = [pos[0]*l+sep,pos[1]*l+sep,pos[2]*l+sep];
        this.model = new Float32Array(16);
        mat4.identity(this.model);
        mat4.translate(this.model,identity,this.pos);
        mat4.scale(this.model,this.model,[0.5,0.5,0.5]);
    }
}



function main() {
    if (gl == null){alert("Unable to initialize WebGL :("); return;}

    var vertex_buffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, vertex_buffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(cube_positions), gl.STATIC_DRAW);
    gl.bindBuffer(gl.ARRAY_BUFFER, null);

    var Index_Buffer = gl.createBuffer();
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, Index_Buffer);
    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(cube_indices), gl.STATIC_DRAW);
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);



    var shader1 = new Shader(fragCode,vertCode,gl);
    shader1.bind(vertex_buffer,Index_Buffer);

    var coord = gl.getAttribLocation(shader1.program, "coordinates");
    gl.vertexAttribPointer(coord, 3, gl.FLOAT, false, 0, 0);
    gl.enableVertexAttribArray(coord);


      // Convert the array of colors into a table for all the vertices.
    
    const colorBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(colors_v2), gl.STATIC_DRAW);
    var color = gl.getAttribLocation(shader1.program, "vertex_color");
    gl.vertexAttribPointer(color,4,gl.FLOAT,false,0,4*colors_v2.length/12);
    gl.enableVertexAttribArray(color)

    const normalBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, normalBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertexNormals),gl.STATIC_DRAW);
    var normals = gl.getAttribLocation(shader1.program,"normals");
    gl.vertexAttribPointer(normals,3,gl.FLOAT,false,0,0);
    gl.enableVertexAttribArray(normals);


    var cube1_corners = []
    for (var n = 0; n<27; n++){
        cube1_corners.push(new sub_cube([n%3,Math.floor(n/3)%3,Math.floor((n)/9)],[Math.floor(n/9),Math.floor(n%9)/3,0]));
    }


    //shader1.bind(vertex_buffer,Index_Buffer);
    gl.enable(gl.DEPTH_TEST);
    gl.depthFunc(gl.LEQUAL);
    gl.clearColor(0.1,0.1,0.1,1.0);
    gl.clearDepth(1.0);
    //cube1_corners[0].type[0] = 3;

    var drag = false;
    var startxy = [0,0];
    var distxy = [0,0];
    var current_rot = -0.3;
    var totalx = 0;
    var totaly = 0;
    var total = 0;
    var keydown = false;


    var cam = new Camera(1.0);
    cam.bind_to_shader(shader1);
    cam.upload(shader1);
    var model_loc = gl.getUniformLocation(shader1.program,"model");
    var color_loc = gl.getUniformLocation(shader1.program,"color");
    var normal_loc = gl.getUniformLocation(shader1.program,"normalMatrix");
    var cam_loc = gl.getUniformLocation(shader1.program,"camPos");

    var old = new Float32Array(16);
    mat4.lookAt(old,[0,0,-8],[0,0,0],[0,1,0]);
    mat4.rotate(cam.view,cam.view,-0.3,[1,0,0]);
    cam.upload(shader1);
    


    function render_scene(delta){
        //cam.slight_rotate(shader1,0.001);
        //total += 0.1*delta;

        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFER_BIT);
    
    
       
        manage_input();
        if (drag){
            totalx += 0.3*delta*distxy[1];
            totaly += 0.3*delta*distxy[0];
            //if (360<totalx) {totalx = abs(totalx-360);}
            //if (360<totaly) {totaly = abs(totaly-360);}
            //console.log(distxy[1]);
            //console.log(totalx);            
            ///mat4.rotate(cam.view,cam.view,-0.3*(distxy[1])*delta*0.01,[1,0,0]);
            mat4.rotate(cam.view,old,-totalx*3.14/360,[1,0,0]);
            mat4.rotate(cam.view,cam.view,totaly*3.14/360,[0,1,0]);
        }
        //cam.slight_rotate(shader1,delta);
        
        
        cam.upload(shader1);
        
        //if (drag){distxy = [Math.abs(MouseEvent.pageX-startxy[0]),Math.abs(MouseEvent.pageY-startxy[1])];}
        //console.log(distxy);


        for (cube in cube1_corners){
            if (1==2){//(cube1_corners[cube].type[0] == 3){
                gl.uniform3fv(color_loc,[cube1_corners[cube].types[0]/2,cube1_corners[cube].types[1]/5,0]);
            }
            gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);

            var offset = cube*6*4*colors_v2.length/162;

            gl.vertexAttribPointer(color,4,gl.FLOAT,false,0,offset);
            gl.uniformMatrix4fv(model_loc,gl.FALSE,cube1_corners[cube].model);
            const normalMatrix = mat4.create();
            mat4.invert(normalMatrix, cam.view);
            mat4.transpose(normalMatrix, normalMatrix);
            gl.uniformMatrix4fv(normal_loc,gl.FALSE,normalMatrix);
            gl.uniform3fv(cam_loc,[0,5,0]);
            gl.drawElements(gl.TRIANGLES, cube_indices.length, gl.UNSIGNED_SHORT,0); 
            gl.uniform3fv(color_loc,[0,0,0]);

        }
    }




    function rotate_face(value,index,rot){
        var anime_que = [];

        for (cube in cube1_corners){
            //console.log(cube1_corners[cube].pos);

            if (Math.round(cube1_corners[cube].pos[index])==Math.round(value)){
                var t = [-(cube1_corners[cube].pos[0]),-(cube1_corners[cube].pos[1]),-((cube1_corners[cube].pos[2]))];
                //var t = [0,0,1.5]
                var t = [rot[0]*2*-1.5+2*t[0],rot[1]*2*-1.5+2*t[1],rot[2]*2*-1.5+2*t[2]];
                var t2 = [-t[0],-t[1],-t[2]];

                //anime_que.push(cube1_corners[cube]);
                //rotation(3.14159265/2,rot,t,t2);
                //interpolate_anim(0, 3.14159265/4,[rot,t,t2]);
                var angle = 3.14159265/2;
                var axis = rot;
                //console.log([cube1_corners[cube].model])
                mat4.translate(cube1_corners[cube].model,cube1_corners[cube].model,t);
                mat4.rotate(cube1_corners[cube].model,cube1_corners[cube].model,angle,axis);
                mat4.translate(cube1_corners[cube].model,cube1_corners[cube].model,t2);

                var pos = new Float32Array(3);  // = [cube1_corners[cube].model[12],cube1_corners[cube].model[13],cube1_corners[cube].model[14]];
                glMatrix.vec3.transformMat4(pos,cube1_corners[cube].pos,cube1_corners[cube].model);
                cube1_corners[cube].pos = pos
                console.log(pos)
                //console.log([cube1_corners[cube].model[3]])
                //var out = new Float32Array(16);
                //var four = [cube1_corners[cube].pos,1].flat();
                //glMatrix.vec4.transformMat4(out,four,cube1_corners[cube].model);
                //cube1_corners[cube].pos = [out[0],out[1],out[2]];
                //cube1_corners[cube].pos = mat4.multiply(cube1_corners[cube].pos,cube1_corners[cube].pos,cube1_corners[cube].model)
                
                
                //console.log(four);


            }
        }
        anim = true;
    }

    function manage_input(){
        document.addEventListener('keydown', (event)=>{

            if (event.key == 'r' && keydown == false){
                rotate_face(1.1,0,[1,0,0]);
                console.log("stretch");
                keydown = true;
            }

            if (event.key == 'l' && keydown == false){
                rotate_face(-1.1,0,[1,0,0]);
                console.log("stretch");
                keydown = true;
            }

            if (event.key == 'u' && keydown == false){
                rotate_face(1.1,1,[0,1,0]);
                console.log("stretch");
                keydown = true;
            }

            if (event.key == 'd' && keydown == false){
                rotate_face(-1.1,1,[0,1,0]);
                console.log("stretch");
                keydown = true;
            }



        },false);

        document.addEventListener('keyup', (event)=>{keydown = false;},false);
        document.addEventListener('mousedown',(event)=>{drag=true; startxy = [event.clientX,event.clientY]},false);
        document.addEventListener('mouseup',(event)=>{drag=false;},false);
        document.addEventListener('mousemove',(event)=>{if (drag){distxy = [(event.clientX-startxy[0]),(event.clientY-startxy[1])];}},false);        
    }



    function interpolate_anim(start,end,action,steps=1000){
        var step = (end-start)/steps;
        for (var n = start; n<end; n+=step){
            rotation(n,action[0],action[1],action[2]);
        }
    }
    function rotation(angle,axis,t,t2){
        console.log([cube1_corners[cube].model[1]])
        mat4.translate(cube1_corners[cube].model,cube1_corners[cube].model,t);
        mat4.rotate(cube1_corners[cube].model,cube1_corners[cube].model,angle,axis);
        mat4.translate(cube1_corners[cube].model,cube1_corners[cube].model,t2);
        cube1_corners[cube].pos = [cube1_corners[cube].model[3],cube1_corners[cube].model[7],cube1_corners[cube].model[11]];
        console.log([cube1_corners[cube].model[1]])
    }
    var then = 0;
    function render(now){
        now *= 0.001;
        const deltaTime = now-then;
        then = now;
        render_scene(deltaTime);
        requestAnimationFrame(render);
    }
    requestAnimationFrame(render);

}





window.onload = main;


